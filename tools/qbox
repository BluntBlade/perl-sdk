#!/usr/bin/env perl

use strict;
use warnings;

use IO::Handle;
use English;
use File::Basename;

use JSON; # external library

use QBox::Engine;
use QBox::Stub;
use QBox::Misc;

use QBox::Tools::SlaveManager;

### up callbacks
my $up_read_progress_as_plain_text = sub {
    my $fh = shift;

    my $prog = {};
    my $line = undef;

    $line = <$fh>;
    if ($line !~ m/^block_count=(\d+)\n/) {
        die "Invalid progress file: No block count.";
    }
    $prog->{blk_count} = $1;

    $prog->{checksums} = [];
    for (my $i = 0; $i < $prog->{blk_count}; ++$i) {
        $line = <$fh>;
        if ($line !~ m/^checksum=(.*)\n/) {
            die "Invalid progress file: Invalid checksum.";
        }

        push @{$prog->{checksums}}, { value => $1 };
    } # for

    $prog->{progs} = [];
    for (my $i = 0; $i < $prog->{blk_count}; ++$i) {
        my $pg = {};

        $line = <$fh>;
        if ($line !~ m/^offset=(\d+)\n/) {
            die "Invalid progress file: Invalid offset.";
        }
        $pg->{offset} = $1;

        $line = <$fh>;
        if ($line !~ m/^rest_size=(\d+)\n/) {
            die "Invalid progress file: Invalid rest size.";
        }
        $pg->{rest_size} = $1;

        $line = <$fh>;
        if ($line !~ m/^ctx=(.*)\n/) {
            die "Invalid progress file: Invalid context.";
        }
        $pg->{ctx} = $1;

        push @{$prog->{progs}}, $pg;
    } # for

    return $prog;
};

my $up_read_progress = sub {
    my $params = shift;
    
    my $prog_fl = $params->{prog_fl};
    return undef if (not defined($prog_fl) or $prog_fl eq q{});
    return undef if (not -r $prog_fl);

    open(my $fh, '<', $prog_fl) or die "$OS_ERROR";

    my $prog = undef;
    if ($prog_fl =~ m/json$/i) {
        local $/ = undef;
        my $text = <$fh>;
        $prog = from_json($text);
    }
    else {
        $prog = $up_read_progress_as_plain_text->($fh);
    }

    close($fh);
    return $prog;
};

my $up_up_write_progress_as_plain_text = sub {
    my $fh   = shift;
    my $prog = shift;

    printf {$fh} "block_count=%d\n", $prog->{blk_count};

    foreach my $cksum (@{$prog->{checksums}}) {
        printf {$fh} "checksum=%s\n", ($cksum->{value} || q{});
    } # foreach

    foreach my $pg (@{$prog->{progs}}) {
        printf {$fh} "offset=%d\n", $pg->{offset};
        printf {$fh} "rest_size=%d\n", $pg->{rest_size};
        printf {$fh} "ctx=%s\n", ($pg->{ctx} || q{});
    } # foreach
};

my $up_write_progress = sub {
    my $params = shift;
    my $prog   = shift;

    my $prog_fl = $params->{prog_fl};
    return if (not defined($prog_fl) or $prog_fl eq q{});

    open(my $fh, '>', $prog_fl) or die "$OS_ERROR";

    if ($prog_fl =~ m/json$/i) {
        printf {$fh} "%s", to_json($prog, { pretty => 1 });
    }
    else {
        $up_up_write_progress_as_plain_text->($fh, $prog);
    }

    close($fh);
};

my $up_blk_abort = sub {
    my $params    = shift;
    my $blk_index = shift;
    my $checksum  = shift;

    my $stop_idx = $params->{stop_idx};
    if (defined($stop_idx) and $blk_index == $stop_idx) {
        print {$params->{out_fh}} "Abort uploading block(#${stop_idx}).\n";
        return 0;
    }
    return 1;
};

my $up_blk_notify = sub {
    my $params    = shift;
    my $blk_index = shift;
    my $checksum  = shift;

    print {$params->{out_fh}} "blk_index=${blk_index}, checksum=[$checksum->{value}]\n";
    $up_blk_abort->($params, $blk_index, $checksum);
};

my $up_chk_abort = sub {
    my $params    = shift;
    my $blk_index = shift;
    my $prog      = shift;

    my $stop_idx = $params->{stop_idx};
    if (defined($stop_idx) and $blk_index == $stop_idx) {
        my $stop_size = $params->{stop_size};
        if (defined($stop_size) and $prog->{offset} >= $stop_size) {
            print {$params->{out_fh}} "Abort uploading chunk(#$prog->{stop_idx}, \@$prog->{offset}).\n";
            return 0;
        }
    }
    return 1;
};

my $up_chk_notify = sub {
    my $params    = shift;
    my $blk_index = shift;
    my $prog      = shift;

    print {$params->{out_fh}} "blk_index=${blk_index}, uploaded=$prog->{offset}, rest=$prog->{rest_size}, ctx=[$prog->{ctx}]\n";
    $up_chk_abort->($params, $blk_index, $prog);
};

### helper routines
my $slave_mgr = undef;
my $cmd_count = 0;

my $debug   = undef;
my $verbose = 0;
my $pretty  = undef;
my $prompt  = undef;

sub fmt_json {
    my $obj = shift;
    if ($pretty) {
        my $json = to_json($obj, { pretty => 1});
        $json =~ s/\n$//;
        return $json;
    }
    return to_json($obj);
} # fmt_json

sub get_opts {
    my $args    = shift;
    my $options = {};
    my $fixed   = [];

    for (my $i = 0; $i < scalar(@$args); ++$i) {
        my $arg = $args->[$i];

        if ($arg =~ m/^(?:--command-file|-f)/) {
            $options->{cmd_files} ||= [];
            push @{$options->{cmd_files}}, $args->[$i + 1];
            ++$i;
            next;
        }

        if ($arg =~ m/^(?:--interact|-i)/) {
            $prompt = 1;
            next;
        }

        if ($arg =~ m/^(?:--debug|-d)/) {
            $debug = 1;
            next;
        }

        if ($arg =~ m/^(?:--verbose|-v)/) {
            $verbose += 1;
            next;
        }

        if ($arg =~ m/^(?:--pretty|-P)/) {
            $pretty = 1;
            next;
        }

        if ($arg =~ m/^(?:--help|-h)/) {
            my $prog_nm = basename($0);
            print "Usage: ${prog_nm} [OPTION] CMD [PARAM=ARG [PARAM=ARG [...]]]\n";
            exit(0);
        }

        if ($arg =~ m/^-/) {
            print STDERR "Unknown option '$arg'.\n";
            exit(1);
        }

        push @$fixed, $arg;
    } # for

    return $fixed, $options;
} # get_opts

my $slave_callback = sub {
    my $proc   = shift;
    my $params = shift;

    my $callback_ln = readline($proc->{mgr_read});
    chomp($callback_ln);
    $callback_ln =~ s/^#\d+\s+//;
    printf "#%d &%d %s\n", $params->{cmd_idx}, $proc->{job}, $callback_ln;
    return undef; # no longer busy
};

sub run_in_slave {
    my $engine  = shift;
    my $cmd_idx = shift;
    my $cmd_ln  = shift;
    my $opts    = shift || {};

    my $proc = $slave_mgr->start($slave_callback, { 'cmd_idx' => $cmd_idx });
    if ($proc->{child}) {
        $cmd_count = 0;

        $verbose = 0;
        $debug   = undef;
        $pretty  = undef;

        $proc->{work_write}->autoflush(1);
        $proc->{work_err}->autoflush(1);
        slave($engine, [\*STDIN]);
        exit(0);
    }

    $proc->{mgr_write}->autoflush(1);
    $cmd_ln =~ s/\s*[&](?:\d*)\s*$//;
    print {$proc->{mgr_write}} "$cmd_ln\n";
} # run_in_slave

sub exec_cmd {
    my $engine = shift;
    my $cmd_ln = shift;
    my $args   = shift;
    my $opts   = shift || {};

    $cmd_count += 1;

    my $first = shift(@$args) || q{};
    my $cmd = lc($first);
    if ($verbose > 0) {
        if ($verbose < 2 and $cmd eq 'set_auth') {
            print "> $first ... #$cmd_count\n";
        }
        else {
            print "> $cmd_ln #$cmd_count\n";
        }
    }

    $args = { map { split('=', $_, 2) } @$args };
    foreach my $value (values(%$args)) {
        eval { $value = from_json($value); };
    } # foreach

    if (defined($opts->{_slave})) {
        delete $opts->{_slave};
        return run_in_slave($engine, $cmd_count, $cmd_ln, $opts);
    }

    if ($cmd eq 'rput' or $cmd eq 'resumable_put') {
        my $notify = {
            'stop_blk'   => $args->{stop_blk},
            'stop_chk'   => $args->{stop_chk},
            'prog_fl'    => $args->{prog_fl},
            'notify_blk' => (defined($args->{stop_blk})) ? $up_blk_notify : $up_blk_abort,
            'notify_chk' => (defined($args->{stop_chk})) ? $up_chk_notify : $up_chk_abort,
            'out_fh'     => \*STDERR,
        };

        if (defined($notify->{stop_chk})) {
            $notify->{stop_blk} ||= 0;
        }

        $args->{notify} = $notify;
    }

    qbox_hash_merge($opts, $args, 'FROM', ['headers']);

    my ($ret, $err) = $engine->$cmd($args, $opts);
    my $msg = $err->{message};
    $msg =~ s/(?!\\)[']/\\'/g;

    printf "#%d code=%d message='%s' ret=%s\n", $cmd_count, $err->{code}, $msg, fmt_json($ret || {});
    if ($pretty) {
        print STDOUT "\n";
    }
    return $ret, $err;
} # exec_cmd

sub oneshot {
    my $engine = shift;
    my $cmd_ln = shift;
    my $args   = shift;
    my $opts   = shift;

    my $cmd = 'auth_by_password';
    my ($ret, $err) = exec_cmd($engine, $cmd, [$cmd]);
    if (not defined($ret)) {
        $cmd = 'auth_by_access_key';
        ($ret, $err) = exec_cmd($engine, $cmd, [$cmd]);
    }
    exec_cmd($engine, $cmd_ln, $args);
} # oneshot

my $brace_re = undef;
$brace_re = qr/\{ (?: [^\{\}] | (??{ $brace_re }) )* \}/x;
my $bracket_re = undef;
$bracket_re = qr/\[ (?: [^\[\]] | (??{ $bracket_re }) )* \]/x;

sub parse_args {
    my $cmd_ln = shift;
    my $args   = shift || [];
    my $opts   = shift || {};

    my $remain = undef;

    $cmd_ln =~ s/^\s+//;
    $cmd_ln =~ s/^[\\]//;
    $cmd_ln =~ s/[#].*$//;
    $cmd_ln =~ s/\s+$//;

    if ($cmd_ln eq q{}) {
        return $args, $opts, " \\";
    }

    if (scalar(@$args) == 0) {
        if ($cmd_ln !~ m/^\s*(\w+)(.*)$/) {
            return $args, $opts, " \\";
        }
        push @$args, $1; # cmd
        $remain = $2;
    }
    else {
        $remain = $cmd_ln;
    }

    if ($remain =~ m/^(.*)\s+[&]((?:\d+)?)$/) {
        my $job = $2 || 0;
        $opts->{_slave} = $job + 0;
        $remain = $1;
    }

    if ($remain eq q{}) {
        return $args, $opts, $remain;
    }
    
    while ($remain =~ m/([^\s=]+=(?:$brace_re|$bracket_re|\S+))\s*/gc) {
        push @$args, $1;
    } # while

    if (pos($remain) < length($remain)) {
        return $args, $opts, substr($remain, pos($remain));
    }
    return $args, $opts, q{};
} # parse_args

sub exec_file {
    my $engine = shift;
    my $fh     = shift;

    my $args   = undef;
    my $opts   = undef;
    my $remain = q{};
    while (1) {
        $slave_mgr->check_done();

        my $cmd_ln = <$fh>;

        if (not defined($cmd_ln)) {
            if ($slave_mgr->is_busy()){
                sleep(1);
                next;
            }
            last;
        }

        chomp($cmd_ln);

        ($args, $opts, $remain) = parse_args("${remain}${cmd_ln}", $args);
        next if ($remain);

        exec_cmd($engine, $cmd_ln, $args, $opts);
        $args   = undef;
        $remain = q{};
    } # while
} # exec_file

sub slave {
    my $engine = shift;
    my $files  = shift || [];
    
    foreach my $fl (@$files) {
        if (ref($fl) eq 'GLOB') {
            exec_file($engine, $fl);
            next;
        }

        open(my $fh, '<', $fl) or die "$OS_ERROR";

        eval {
            exec_file($engine, $fh);
        };
        close($fh);

        if ($EVAL_ERROR) {
            die "$EVAL_ERROR";
        }
    } # foreach
} # slave

sub prompt {
    my $engine = shift;
    return;
} # prompt

### main
my ($args, $options) = get_opts(\@ARGV);

QBox::Stub::set_stub(sub {
    my ($data, $title, $context) = @_;

    # may echo context
    if ($debug) {
        my $type = ref($$context);
        if ($type eq 'HASH' or $type eq 'ARRAY') {
            printf STDERR "${title}=%s\n", fmt_json($$context);
        }
        else {
            print STDERR "${title}=[$${context}]\n";
        }
    }

    return 1;
});

eval {
    $slave_mgr = QBox::Tools::SlaveManager->new();

    my $engine = QBox::Engine->new();

    if (scalar(@{$options->{cmd_files}}) > 0) {
        slave($engine, $options->{cmd_files});
    }

    my $cmd = $args->[0] || '';
    if ($cmd =~ m/^\w+$/) {
        oneshot($engine, "@$args", $args);
    }

    if (not -t STDIN) {
        if (not eof(STDIN)) {
            slave($engine, [\*STDIN]);
        }

        if ($prompt) {
            prompt($engine);
        }
    }
    else {
        prompt($engine);
    }
};

if ($EVAL_ERROR) {
    print "$EVAL_ERROR\n";
    exit(1);
}
