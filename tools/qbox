#!/usr/bin/env perl

use strict;
use warnings;

use English;
use File::Basename;

use JSON; # external library

use QBox::Engine;
use QBox::Stub;
use QBox::Misc;

### up callbacks
my $up_read_progress_as_plain_text = sub {
    my $fh = shift;

    my $prog = {};
    my $line = undef;

    $line = <$fh>;
    if ($line !~ m/^block_count=(\d+)\n/) {
        die "Invalid progress file: No block count.";
    }
    $prog->{blk_count} = $1;

    $prog->{checksums} = [];
    for (my $i = 0; $i < $prog->{blk_count}; ++$i) {
        $line = <$fh>;
        if ($line !~ m/^checksum=(.*)\n/) {
            die "Invalid progress file: Invalid checksum.";
        }

        push @{$prog->{checksums}}, { value => $1 };
    } # for

    $prog->{progs} = [];
    for (my $i = 0; $i < $prog->{blk_count}; ++$i) {
        my $pg = {};

        $line = <$fh>;
        if ($line !~ m/^offset=(\d+)\n/) {
            die "Invalid progress file: Invalid offset.";
        }
        $pg->{offset} = $1;

        $line = <$fh>;
        if ($line !~ m/^rest_size=(\d+)\n/) {
            die "Invalid progress file: Invalid rest size.";
        }
        $pg->{rest_size} = $1;

        $line = <$fh>;
        if ($line !~ m/^ctx=(.*)\n/) {
            die "Invalid progress file: Invalid context.";
        }
        $pg->{ctx} = $1;

        push @{$prog->{progs}}, $pg;
    } # for

    return $prog;
};

my $up_read_progress = sub {
    my $params = shift;
    
    my $prog_fl = $params->{prog_fl};
    return undef if (not defined($prog_fl) or $prog_fl eq q{});
    return undef if (not -r $prog_fl);

    open(my $fh, '<', $prog_fl) or die "$OS_ERROR";

    my $prog = undef;
    if ($prog_fl =~ m/json$/i) {
        local $/ = undef;
        my $text = <$fh>;
        $prog = from_json($text);
    }
    else {
        $prog = $up_read_progress_as_plain_text->($fh);
    }

    close($fh);
    return $prog;
};

my $up_up_write_progress_as_plain_text = sub {
    my $fh   = shift;
    my $prog = shift;

    printf {$fh} "block_count=%d\n", $prog->{blk_count};

    foreach my $cksum (@{$prog->{checksums}}) {
        printf {$fh} "checksum=%s\n", ($cksum->{value} || q{});
    } # foreach

    foreach my $pg (@{$prog->{progs}}) {
        printf {$fh} "offset=%d\n", $pg->{offset};
        printf {$fh} "rest_size=%d\n", $pg->{rest_size};
        printf {$fh} "ctx=%s\n", ($pg->{ctx} || q{});
    } # foreach
};

my $up_write_progress = sub {
    my $params = shift;
    my $prog   = shift;

    my $prog_fl = $params->{prog_fl};
    return if (not defined($prog_fl) or $prog_fl eq q{});

    open(my $fh, '>', $prog_fl) or die "$OS_ERROR";

    if ($prog_fl =~ m/json$/i) {
        printf {$fh} "%s", to_json($prog, { pretty => 1 });
    }
    else {
        $up_up_write_progress_as_plain_text->($fh, $prog);
    }

    close($fh);
};

my $up_blk_abort = sub {
    my $params    = shift;
    my $blk_index = shift;
    my $checksum  = shift;

    my $stop_idx = $params->{stop_idx};
    if (defined($stop_idx) and $blk_index == $stop_idx) {
        print {$params->{out_fh}} "Abort uploading block(#${stop_idx}).\n";
        return 0;
    }
    return 1;
};

my $up_blk_notify = sub {
    my $params    = shift;
    my $blk_index = shift;
    my $checksum  = shift;

    print {$params->{out_fh}} "blk_index=${blk_index}, checksum=[$checksum->{value}]\n";
    $up_blk_abort->($params, $blk_index, $checksum);
};

my $up_chk_abort = sub {
    my $params    = shift;
    my $blk_index = shift;
    my $prog      = shift;

    my $stop_idx = $params->{stop_idx};
    if (defined($stop_idx) and $blk_index == $stop_idx) {
        my $stop_size = $params->{stop_size};
        if (defined($stop_size) and $prog->{offset} >= $stop_size) {
            print {$params->{out_fh}} "Abort uploading chunk(#$prog->{stop_idx}, \@$prog->{offset}).\n";
            return 0;
        }
    }
    return 1;
};

my $up_chk_notify = sub {
    my $params    = shift;
    my $blk_index = shift;
    my $prog      = shift;

    print {$params->{out_fh}} "blk_index=${blk_index}, uploaded=$prog->{offset}, rest=$prog->{rest_size}, ctx=[$prog->{ctx}]\n";
    $up_chk_abort->($params, $blk_index, $prog);
};

### helper routines
my $conf    = undef;
my $debug   = undef;
my $verbose = 0;
my $pretty  = undef;
my $batch   = undef;
my $prompt  = undef;

sub fmt_json {
    my $obj = shift;
    if ($pretty) {
        my $json = to_json($obj, { pretty => 1});
        $json =~ s/\n$//;
        return $json;
    }
    return to_json($obj);
} # fmt_json

sub get_opts {
    my $args    = shift;
    my $options = {};
    my $fixed   = [];

    for (my $i = 0; $i < scalar(@$args); ++$i) {
        my $arg = $args->[$i];

        if ($arg =~ m/^(?:--command-file|-f)/) {
            $options->{cmd_files} ||= [];
            push @{$options->{cmd_files}}, $args->[$i + 1];
            ++$i;
            next;
        }

        if ($arg =~ m/^(?:--interact|-i)/) {
            $prompt = 1;
            next;
        }

        if ($arg =~ m/^(?:--debug|-d)/) {
            $debug = 1;
            next;
        }

        if ($arg =~ m/^(?:--verbose|-v)/) {
            $verbose += 1;
            next;
        }

        if ($arg =~ m/^(?:--pretty|-P)/) {
            $pretty = 1;
            next;
        }

        if ($arg =~ m/^(?:--help|-h)/) {
            my $prog_nm = basename($0);
            print "Usage: ${prog_nm} [OPTION] CMD [PARAM=ARG [PARAM=ARG [...]]]\n";
            exit(0);
        }

        if ($arg =~ m/^-/) {
            print STDERR "Unknown option '$arg'.\n";
            exit(1);
        }

        push @$fixed, $arg;
    } # for

    return $fixed, $options;
} # get_opts

sub exec_cmd {
    my $engine = shift;
    my $args   = shift;
    my $opts   = shift || {};

    print "> @$args\n";

    my $cmd = shift(@$args);
    $args = { map { split('=', $_, 2) } @$args };
    foreach my $value (values(%$args)) {
        eval { $value = from_json($value); };
    } # foreach

    if ($cmd eq 'rput' or $cmd eq 'resumable_put') {
        my $notify = {
            'stop_blk'   => $args->{stop_blk},
            'stop_chk'   => $args->{stop_chk},
            'prog_fl'    => $args->{prog_fl},
            'notify_blk' => (defined($args->{stop_blk})) ? $up_blk_notify : $up_blk_abort,
            'notify_chk' => (defined($args->{stop_chk})) ? $up_chk_notify : $up_chk_abort,
            'out_fh'     => \*STDERR,
        };

        if (defined($notify->{stop_chk})) {
            $notify->{stop_blk} ||= 0;
        }

        $args->{notify} = $notify;
    }

    $args->{bucket} ||= 'Bucket';
    $args->{key}    ||= (defined($args->{src}) ? basename($args->{src}) : undef;

    qbox_hash_merge($opts, $args, 'FROM', ['headers']);
    my ($ret, $err) = $engine->$cmd($args, $opts);
    if ($verbose or ($err->{code} != 200)) {
        printf STDERR "%d %s\n", $err->{code}, $err->{message};
    }

    printf "%s\n", fmt_json($ret || {});
    return $ret, $err;
} # exec_cmd

sub oneshot {
    my $engine = shift;
    my $args   = shift;
    my $opts   = shift;

    my ($ret, $err) = exec_cmd($engine, ['auth_by_password']);
    if (not defined($ret)) {
        ($ret, $err) = exec_cmd($engine, ['auth_by_access_key']);
    }
    exec_cmd($engine, $args);
} # oneshot

my $brace_re = undef;
$brace_re = qr/\{ (?: [^\{\}] | (??{ $brace_re }) )* \}/x;
my $bracket_re = undef;
$bracket_re = qr/\[ (?: [^\[\]] | (??{ $bracket_re }) )* \]/x;

sub parse_args {
    my $cmd_ln = shift;
    my $args   = shift || [];

    my $remain = undef;

    $cmd_ln =~ s/^\s+[\\]?//;
    $cmd_ln =~ s/[#].*$//;
    $cmd_ln =~ s/\s+$//;

    if ($cmd_ln eq q{}) {
        return $args, " \\";
    }

    if (scalar(@$args) == 0) {
        if ($cmd_ln !~ m/^\s*(\w+)(.*)$/) {
            return $args, " \\";
        }
        push @$args, $1; # cmd
        $remain = $2;
    }

    if ($remain eq q{}) {
        return $args, $remain;
    }
    
    while ($remain =~ m/([^\s=]+=(?:$brace_re|$bracket_re|\S+))\s*/gc) {
        push @$args, $1;
    } # while

    if (pos($remain) < length($remain)) {
        return $args, substr($remain, pos($remain));
    }
    return $args, q{};
} # parse_args

sub exec_file {
    my $engine = shift;
    my $fh     = shift;

    my $args   = undef;
    my $remain = q{};
    while (my $cmd_ln = <$fh>) {
        chomp($cmd_ln);

        ($args, $remain) = parse_args("${remain}${cmd_ln}", $args);
        if ($remain) {
            next;
        }

        exec_cmd($engine, $args);
        $args   = undef;
        $remain = q{};
    } # while
} # exec_file

sub batch {
    my $engine = shift;
    my $files  = shift || [];
    
    foreach my $fl (@$files) {
        if (ref($fl) eq 'GLOB') {
            exec_file($engine, $fl);
            next;
        }

        open(my $fh, '<', $fl) or die "$OS_ERROR";

        eval {
            exec_file($engine, $fh);
        };
        close($fh);

        if ($EVAL_ERROR) {
            die "$EVAL_ERROR";
        }
    } # foreach

    return;
} # batch

sub prompt {
    my $engine = shift;
    return;
} # prompt

### main
my ($args, $options) = get_opts(\@ARGV);

QBox::Stub::set_stub(sub {
    my ($data, $title, $context) = @_;

    # may echo context
    if ($debug) {
        my $type = ref($$context);
        if ($type eq 'HASH' or $type eq 'ARRAY') {
            printf STDERR "${title}=%s\n", fmt_json($$context);
        }
        else {
            print STDERR "${title}=[$${context}]\n";
        }
    }

    return 1;
});

eval {
    my $engine = QBox::Engine->new();

    if (scalar(@{$options->{cmd_files}}) > 0) {
        batch($engine, $options->{cmd_files});
    }

    my $cmd = $args->[0] || '';
    if ($cmd =~ m/^\w+$/) {
        oneshot($engine, $args);
    }

    if (not -t STDIN) {
        if (not eof(STDIN)) {
            batch($engine, [\*STDIN]);
        }

        if ($prompt) {
            prompt($engine);
        }
    }
    else {
        prompt($engine);
    }
};

if ($EVAL_ERROR) {
    print "$EVAL_ERROR\n";
    exit(1);
}
