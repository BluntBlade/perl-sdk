#!/usr/bin/env perl

use strict;
use warnings;

use English;
use File::Basename;

use JSON;                            # external library
use Net::Curl::Easy qw(:constants);  # external library

use QBox::Base::Curl;
use QBox::Auth::Password;
use QBox::Auth::Token;
use QBox::Auth::Digest;
use QBox::Auth::UpToken;
use QBox::Auth::Policy;
use QBox::Client;
use QBox::RS;
use QBox::UP;
use QBox::EU;
use QBox::UC;
use QBox::Misc;
use QBox::ReaderAt::File;
use QBox::Stub;

my $conf   = undef;
my $debug  = undef;
my $verbose = undef;
my $pretty = undef;

sub fmt_json {
    my $obj = shift;
    if ($pretty) {
        my $json = to_json($obj, { pretty => 1});
        $json =~ s/\n$//;
        return $json;
    }
    return to_json($obj);
} # fmt_json

sub pickup_param {
    foreach my $p (@_) {
        if (defined($p)) {
            return $p;
        }
    } # foreach
    return undef;
} # pickup_param

sub get_opts {
    my $args  = shift;
    my $opts  = {};
    my $fixed = [];

    for (my $i = 0; $i < scalar(@$args); ++$i) {
        my $arg = $args->[$i];

        if ($arg =~ m/^(?:--conf|-f)/) {
            $opts->{conf} ||= [];
            push @{$opts->{conf}}, $args->[$i + 1];
            ++$i;
            next;
        }

        if ($arg =~ m/^(?:--debug|-d)/) {
            $debug = 1;
            next;
        }

        if ($arg =~ m/^(?:--verbose|-v)/) {
            $verbose = 1;
            next;
        }

        if ($arg =~ m/^(?:--pretty|-P)/) {
            $pretty = 1;
            next;
        }

        if ($arg =~ m/^-/) {
            print STDERR "Unknown option '$arg'.\n";
            exit(1);
        }

        push @$fixed, $arg;
    } # for

    return $fixed, $opts;
} # get_opts

sub parse_params {
    my $args = shift;
    return { map { split('=', $_, 2) } @$args };
} # parse_params

sub merge_hash {
    my $to   = shift;
    my $from = shift;
    my $keys = shift || [keys(%$to)];

    foreach my $key (@$keys) {
        if (exists($from->{$key})) {
            if (ref($from->{$key}) eq 'HASH') {
                $to->{$key} ||= {};
                merge_hash($to->{$key}, $from->{$key}, [keys(%{$from->{$key}})]);
            }
            else {
                $to->{$key} = $from->{$key};
            }
        }
    } # foreach

    return $to;
} # merge_hash

sub get_json {
    my $text = shift;
    my $json = undef;
    
    if (-r $text) {
        open(my $fh, '<', $text) or die "$OS_ERROR";
        local $INPUT_RECORD_SEPARATOR = undef;
        $text = <$fh>;
        close($fh);
    }

    eval {
        $json = from_json($text);
    };

    if ($EVAL_ERROR) {
        die "${EVAL_ERROR}(text=${text})";
    }

    return $json;
} # get_json

sub mod_http_headers {
    my $src = shift;
    my $dst = shift;

    if (ref($src->{del}) eq 'ARRAY') {
        foreach my $header (@{$src->{del}}) {
            my $re = "^${header}\\s*:";
            $$dst = [grep { $_ !~ $re } @{$$dst}];
        } # foreach
    }

    if (ref($src->{add}) eq 'ARRAY') {
        push @{$$dst}, @{$src->{add}};
    }
} # mod_http_headers

sub read_conf {
    my $fls = shift;

    my $conf = {};
    foreach my $fl (@$fls) {
        next if (not defined($fl) or $fl eq q{});

        open(my $fh, '<', $fl) or die "$!";
        local $/ = undef;
        my $text = <$fh>;
        close($fh);

        my $new_conf = undef;
        eval {
            $new_conf = from_json($text);
        };
        if ($EVAL_ERROR) {
            die "$EVAL_ERROR(fl=${fl})";
        }

        merge_hash($conf, $new_conf, [keys(%$new_conf)]);
    } # foreach

    return $conf;
} # read_conf

sub gen_client {
    my $login = shift;
    my $hosts  = shift;

    my $client_id     = pickup_param($login->{client_id});
    my $client_secret = pickup_param($login->{client_secret});
    my $username      = pickup_param($login->{username});
    my $password      = pickup_param($login->{password});

    if (defined($username) and defined($password)) {
        my $token = QBox::Auth::Token->new($hosts, $client_id, $client_secret);
        my $auth = QBox::Auth::Password->new($token, $username, $password);
        return QBox::Client->new($auth);
    }

    my $acs_key = pickup_param($login->{acs_key}, 'Put your ACCESS KEY here');
    my $scr_key = pickup_param($login->{scr_key}, 'Put your SECRET KEY here');

    my $policy = pickup_param($login->{policy});
    if (defined($policy) and $policy ne q{}) {
        if (ref($policy) eq q{}) {
            $policy = from_json($policy);
        }
        $policy = QBox::Auth::Policy->new($policy);
        my $auth = QBox::Auth::UpToken->new($acs_key, $scr_key, $policy);
        return QBox::Client->new($auth);
    }

    my $auth = QBox::Auth::Digest->new($acs_key, $scr_key);
    return QBox::Client->new($auth);
} # gen_client

### rs
my $rs_get_params = sub {
    my $params = shift;

    my $rs_params = {};

    $rs_params->{src_file}        = pickup_param($params->{src}, q{});
    $rs_params->{bucket}          = pickup_param($params->{bkt}, 'Bucket');
    $rs_params->{key}             = pickup_param($params->{key}, basename($rs_params->{src_file}));
    $rs_params->{mime}            = pickup_param($params->{mime}, 'application/octet-stream');
    $rs_params->{meta}            = pickup_param($params->{meta});
    $rs_params->{other_params}    = pickup_param($params->{params});
    $rs_params->{callback_params} = pickup_param($params->{callback_params});

    $rs_params->{attr}            = pickup_param($params->{attr});
    $rs_params->{base}            = pickup_param($params->{base});
    $rs_params->{domain}          = pickup_param($params->{domain});

    return $rs_params;
};

### up
my $up_read_progress_as_plain_text = sub {
    my $fh = shift;

    my $prog = {};
    my $line = undef;

    $line = <$fh>;
    if ($line !~ m/^block_count=(\d+)\n/) {
        die "Invalid progress file: No block count.";
    }
    $prog->{blk_count} = $1;

    $prog->{checksums} = [];
    for (my $i = 0; $i < $prog->{blk_count}; ++$i) {
        $line = <$fh>;
        if ($line !~ m/^checksum=(.*)\n/) {
            die "Invalid progress file: Invalid checksum.";
        }

        push @{$prog->{checksums}}, { value => $1 };
    } # for

    $prog->{progs} = [];
    for (my $i = 0; $i < $prog->{blk_count}; ++$i) {
        my $pg = {};

        $line = <$fh>;
        if ($line !~ m/^offset=(\d+)\n/) {
            die "Invalid progress file: Invalid offset.";
        }
        $pg->{offset} = $1;

        $line = <$fh>;
        if ($line !~ m/^rest_size=(\d+)\n/) {
            die "Invalid progress file: Invalid rest size.";
        }
        $pg->{rest_size} = $1;

        $line = <$fh>;
        if ($line !~ m/^ctx=(.*)\n/) {
            die "Invalid progress file: Invalid context.";
        }
        $pg->{ctx} = $1;

        push @{$prog->{progs}}, $pg;
    } # for

    return $prog;
};

my $up_read_progress = sub {
    my $params = shift;
    
    my $prog_fl = $params->{prog_fl};
    return undef if (not defined($prog_fl) or $prog_fl eq q{});
    return undef if (not -r $prog_fl);

    open(my $fh, '<', $prog_fl) or die "$OS_ERROR";

    my $prog = undef;
    if ($prog_fl =~ m/json$/i) {
        local $/ = undef;
        my $text = <$fh>;
        $prog = from_json($text);
    }
    else {
        $prog = $up_read_progress_as_plain_text->($fh);
    }

    close($fh);
    return $prog;
};

my $up_up_write_progress_as_plain_text = sub {
    my $fh   = shift;
    my $prog = shift;

    printf {$fh} "block_count=%d\n", $prog->{blk_count};

    foreach my $cksum (@{$prog->{checksums}}) {
        printf {$fh} "checksum=%s\n", ($cksum->{value} || q{});
    } # foreach

    foreach my $pg (@{$prog->{progs}}) {
        printf {$fh} "offset=%d\n", $pg->{offset};
        printf {$fh} "rest_size=%d\n", $pg->{rest_size};
        printf {$fh} "ctx=%s\n", ($pg->{ctx} || q{});
    } # foreach
};

my $up_write_progress = sub {
    my $params = shift;
    my $prog   = shift;

    my $prog_fl = $params->{prog_fl};
    return if (not defined($prog_fl) or $prog_fl eq q{});

    open(my $fh, '>', $prog_fl) or die "$OS_ERROR";

    if ($prog_fl =~ m/json$/i) {
        printf {$fh} "%s", to_json($prog, { pretty => 1 });
    }
    else {
        $up_up_write_progress_as_plain_text->($fh, $prog);
    }

    close($fh);
};

my $up_blk_abort = sub {
    my $params    = shift;
    my $blk_index = shift;
    my $checksum  = shift;

    my $stop_idx = $params->{stop_idx};
    if (defined($stop_idx) and $blk_index == $stop_idx) {
        print "Abort uploading block(#${stop_idx}).\n";
        return 0;
    }
    return 1;
};

my $up_blk_notify = sub {
    my $params    = shift;
    my $blk_index = shift;
    my $checksum  = shift;

    printf "blk_index=%d, checksum=[%s]\n", $blk_index, $checksum->{value};
    $up_blk_abort->($params, $blk_index, $checksum);
};

my $up_chk_abort = sub {
    my $params    = shift;
    my $blk_index = shift;
    my $prog      = shift;

    my $stop_idx = $params->{stop_idx};
    if (defined($stop_idx) and $blk_index == $stop_idx) {
        my $stop_size = $params->{stop_size};
        if (defined($stop_size) and $prog->{offset} >= $stop_size) {
            print "Abort uploading chunk(#$prog->{stop_idx}, \@$prog->{offset}).\n";
            return 0;
        }
    }
    return 1;
};

my $up_chk_notify = sub {
    my $params    = shift;
    my $blk_index = shift;
    my $prog      = shift;

    printf "blk_index=%d, uploaded=%d, rest=%d, ctx=[%s]\n",
        $blk_index, $prog->{offset}, $prog->{rest_size}, $prog->{ctx};
    $up_chk_abort->($params, $blk_index, $prog);
};

### eu
my $eu_gen_settings = sub {
    my $params   = shift;
    my $settings = shift || {};

    my $wms   = pickup_param($params->{wms});
    my $names = QBox::EU::wm_setting_names();

    merge_hash($settings, $conf, $names);
    if (defined($wms) and $wms ne q{}) {
        merge_hash($settings, get_json($wms), $names);
    }
    merge_hash($settings, $params, $names);

    return $settings;
};

my %cmd_alias = (
    'get'   => 'rs.get',
    'stat'  => 'rs.stat',
    'pub'   => 'rs.publish',
    'unpub' => 'rs.unpublish',
    'puta'  => 'rs.put-auth',
    'putaf' => 'rs.put-auth-file',
    'putf'  => 'rs.put-file',
    'rput'  => 'rs.resumable-put',
    'del'   => 'rs.delete',
    'drop'  => 'rs.drop',
    'query' => 'up.query',
    'wmget' => 'eu.wmget',
    'wmset' => 'eu.wmset',
    'wmmod' => 'eu.wmmod',
    'appi'  => 'uc.app-info',
    'nacs'  => 'uc.new-access',
    'dacs'  => 'uc.delete-access',
);

my %cmds = (
    'rs.get' => sub { # command
        my ($client, $params, $hosts) = @_;

        my $rs_params = $rs_get_params->($params);
        my $rs = QBox::RS->new($client, $hosts);
        return $rs->get(
            $rs_params->{bucket},
            $rs_params->{key},
            $rs_params->{attr},
            $rs_params->{base},
        );
    },
    'rs.stat' => sub { # command
        my ($client, $params, $hosts) = @_;

        my $rs_params = $rs_get_params->($params);
        my $rs = QBox::RS->new($client, $hosts);
        return $rs->stat($rs_params->{bucket}, $rs_params->{key});
    },
    'rs.publish' => sub { # command
        my ($client, $params, $hosts) = @_;

        my $rs_params = $rs_get_params->($params);
        my $rs = QBox::RS->new($client, $hosts);
        return $rs->publish($rs_params->{bucket}, $rs_params->{domain});
    },
    'rs.unpublish' => sub { # command
        my ($client, $params, $hosts) = @_;

        my $rs_params = $rs_get_params->($params);
        my $rs = QBox::RS->new($client, $hosts);
        return $rs->unpublish($rs_params->{domain});
    },
    'rs.put-auth' => sub { # command
        my ($client, $params, $hosts) = @_;

        my $expires_in   = pickup_param($params->{expires_in}, 30);

        my $rs = QBox::RS->new($client, $hosts);
        return $rs->put_auth($expires_in);
    },
    'rs.put-auth-ex' => sub { # command
        my ($client, $params, $hosts) = @_;

        my $expires_in   = pickup_param($params->{expires_in}, 30);
        my $callback_url = pickup_param($params->{callback_url});

        my $rs = QBox::RS->new($client, $hosts);
        return $rs->put_auth_ex($expires_in, $callback_url);
    },
    'rs.put-file' => sub { # command
        my ($client, $params, $hosts) = @_;

        my $rs_params = $rs_get_params->($params);

        my $rs = QBox::RS->new($client, $hosts);
        return $rs->put_file(
            $rs_params->{bucket},
            $rs_params->{key},
            $rs_params->{mime_type},
            $rs_params->{src_file},
            $rs_params->{meta},
        );
    },
    'rs.resumable-put' => sub { # command
        my ($client, $params, $hosts) = @_;

        my $rs_params = $rs_get_params->($params);

        my $fsize     = (stat($rs_params->{src_file}))[7];
        my $reader_at = QBox::ReaderAt::File->new($rs_params->{src_file});

        my $notify_blk = pickup_param($params->{notify_blk});
        my $notify_chk = pickup_param($params->{notify_chk});

        my $notify_params = {};
        $notify_params->{stop_idx}  = pickup_param($params->{stop_idx});
        $notify_params->{stop_size} = pickup_param($params->{stop_size});
        $notify_params->{prog_fl}   = pickup_param($params->{prog_fl});

        if (defined($notify_params->{stop_size})) {
            $notify_params->{stop_idx} ||= 0;
        }

        my $ret  = undef;
        my $err  = undef;
        my $prog = $up_read_progress->($notify_params);

        my $rs = QBox::RS->new($client, $hosts);
        ($ret, $err, $prog) = $rs->resumale_put(
            $prog,
            defined($notify_blk) ? $up_blk_notify : $up_blk_abort,
            defined($notify_chk) ? $up_chk_notify : $up_chk_abort,
            $notify_params,
            qbox_make_entry($rs_params->{bucket}, $rs_params->{key}),
            $rs_params->{mime},
            $reader_at,
            $fsize,
            $rs_params->{meta},
            $rs_params->{other_params},
            $rs_params->{callback_params},
        );

        if ($err->{code} != 200) {
            $up_write_progress->($notify_params, $prog);
        }
        elsif ($notify_params->{prog_fl} and -w $notify_params->{prog_fl}) {
            unlink($notify_params->{prog_fl});
        }

        return $ret, $err;
    },
    'rs.delete' => sub { # command
        my ($client, $params, $hosts) = @_;

        my $rs_params = $rs_get_params->($params);
        my $rs = QBox::RS->new($client, $hosts);
        return $rs->delete($rs_params->{bucket}, $rs_params->{key});
    },
    'rs.drop' => sub { # command
        my ($client, $params, $hosts) = @_;

        my $rs_params = $rs_get_params->($params);
        my $rs = QBox::RS->new($client, $hosts);
        return $rs->drop($rs_params->{bucket});
    },
    'up.query' => sub { # command
        my ($client, $params, $hosts) = @_;

        my $prog_fl = pickup_param($params->{prog_fl});
        my $prog    = $up_read_progress->({ prog_fl => $prog_fl });

        if (not defined($prog)) {
            return undef, { code => 299, message => 'No correct progress infomation.' };
        }

        my $up = QBox::UP->new($client, $hosts);
        return $up->query($prog->{checksums});
    },
    'eu.wmget' => sub { # command
        my ($client, $params, $hosts) = @_;

        my $customer = pickup_param($params->{customer});
        my $eu = QBox::EU->new($client, $hosts);
        return $eu->wmget($customer);
    },
    'eu.wmset' => sub { # command
        my ($client, $params, $hosts) = @_;

        my $settings = $eu_gen_settings->($params);
        my $eu = QBox::EU->new($client, $hosts);
        return $eu->wmset($settings);
    },
    'uc.app-info' => sub { # command
        my ($client, $params, $hosts) = @_;

        my $app = pickup_param($params->{app});

        my $uc = QBox::UC->new($client, $hosts);
        return $uc->app_info($app);
    },
    'uc.new-access' => sub { # command
        my ($client, $params, $hosts) = @_;

        my $app = pickup_param($params->{app});

        my $uc = QBox::UC->new($client, $hosts);
        return $uc->new_access($app);
    },
    'uc.delete-access' => sub { # command
        my ($client, $params, $hosts) = @_;

        my $app     = pickup_param($params->{app});
        my $acs_key = pickup_param($params->{acs_key});

        my $uc = QBox::UC->new($client, $hosts);
        return $uc->delete_access($app, $acs_key);
    },
);

my %ext_cmds = (
    'eu.wmmod' => sub { # command extended
        my ($client, $params, $hosts) = @_;

        my ($settings, $err) = $cmds{'eu.wmget'}->($client, $params, $hosts);
        if ($err->{code} != 200) {
            return undef, $err;
        }

        $settings = $eu_gen_settings->($params, $settings);
        my $eu = QBox::EU->new($client, $hosts);
        return $eu->wmset($settings);
    },
    'rs.put-auth-file' => sub { # command extended
        my ($client, $params, $hosts) = @_;

        my ($ret, $err) = $cmds{'rs.put-auth-ex'}->(@_);
        return $ret, $err if ($err->{code} != 200);

        my $rs_params = $rs_get_params->($params);
        my $entry     = qbox_make_entry($rs_params->{bucket}, $rs_params->{key});
        my $mime      = pickup_param($rs_params->{mime}, 'application/octet-stream');

        $entry        = qbox_base64_encode_urlsafe($entry);
        $mime         = qbox_base64_encode_urlsafe($mime);

        my $body = {
            action => "/rs-put/${entry}/mimeType/${mime}",
            params => pickup_param($rs_params->{other_params}, q{}),
        };
        
        my $file_body = {
            file => $rs_params->{src_file},
        };

        if ($verbose) {
            printf STDERR "putaf : body=%s\n", fmt_json($body);
            printf STDERR "putaf : file=%s\n", fmt_json($file_body);
        }

        my $form = qbox_curl_make_multipart_form($body, $file_body);
        my $curl = qbox_curl_call_pre(
            $ret->{url},
            undef,
            { 'api' => 'rs.put-auth-file' }
        );
        $curl->setopt(CURLOPT_HTTPPOST, $form);
        return qbox_curl_call_core($curl);
    },
);

my ($args, $opts) = get_opts(\@ARGV);
$conf = read_conf($opts->{conf});

my $cmd = shift(@$args);

if (not defined($cmd) or $cmd eq q{}) {
    my $prog_nm = basename($0);
    print "Usage: ${prog_nm} CMD [PARAM=ARG [PARAM=ARG [...]]]\n";
    exit(1);
}

$cmd = $cmd_alias{$cmd} || $cmd;
my $cmd_sub = $ext_cmds{$cmd} || $cmds{$cmd};
if (not defined($cmd_sub)) {
    print STDERR "Unknown command '$cmd'.\n";
    exit(1);
}

my $rc = {
    login   => {},
    params  => {},
    headers => {},
};

merge_hash($rc, $conf, [keys(%$conf)]);

my $params = parse_params($args);
merge_hash($rc->{params}, $params, [keys(%$params)]);

QBox::Stub::set_stub(sub {
    my ($data, $title, $context) = @_;

    # may modify http headers
    if ($title =~ m/^(.+)[.]headers$/) {
        if (ref($rc->{headers}{$1}) eq 'HASH') {
            mod_http_headers($rc->{headers}{$1}, $context);
        }
        if (ref($rc->{headers}{all}) eq 'HASH') {
            mod_http_headers($rc->{headers}{all}, $context);
        }
    }

    # may echo context
    if ($debug) {
        my $type = ref($$context);
        if ($type eq 'HASH' or $type eq 'ARRAY') {
            printf STDERR "${title}=%s\n", fmt_json($$context);
        }
        else {
            print STDERR "${title}=[$${context}]\n";
        }
    }
});

my $hosts  = $rc->{hosts} || {};
my $client = gen_client($rc->{login}, $hosts);

my ($ret, $err) = $cmd_sub->($client, $rc->{params}, $hosts);

if ($verbose or ($err->{code} != 200)) {
    printf STDERR "%d %s\n", $err->{code}, $err->{message};
}

$ret ||= {};
printf "%s\n", fmt_json($ret);

exit 0;
