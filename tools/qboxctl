#!/usr/bin/env perl

use strict;
use warnings;

use English;
use File::Basename;

use JSON; # external library

use QBox::Auth::Password;
use QBox::Auth::Token;
use QBox::Auth::Digest;
use QBox::Auth::UpToken;
use QBox::Auth::Policy;
use QBox::Client;
use QBox::RS;
use QBox::UP;
use QBox::EU;
use QBox::UC;
use QBox::Misc;
use QBox::ReaderAt::File;

my $conf   = undef;
my $debug  = undef;
my $verbose = undef;
my $pretty = undef;

sub fmt_json {
    my $obj = shift;
    if ($pretty) {
        my $json = to_json($obj, { pretty => 1});
        $json =~ s/\n$//;
        return $json;
    }
    return to_json($obj);
} # fmt_json

sub get_param {
    foreach my $p (@_) {
        if (defined($p)) {
            return $p;
        }
    } # foreach
    return undef;
} # get_param

sub get_opts {
    my $args  = shift;
    my $opts  = {};
    my $fixed = [];

    for (my $i = 0; $i < scalar(@$args); ++$i) {
        my $arg = $args->[$i];

        if ($arg =~ m/^(?:--conf|-f)/) {
            $opts->{conf} ||= [];
            push @{$opts->{conf}}, $args->[$i + 1];
            ++$i;
            next;
        }

        if ($arg =~ m/^(?:--debug|-d)/) {
            $debug = 1;
            next;
        }

        if ($arg =~ m/^(?:--verbose|-v)/) {
            $verbose = 1;
            next;
        }

        if ($arg =~ m/^(?:--pretty|-P)/) {
            $pretty = 1;
            next;
        }

        if ($arg =~ m/^-/) {
            print STDERR "Unknown option '$arg'.\n";
            exit(1);
        }

        push @$fixed, $arg;
    } # for

    return $fixed, $opts;
} # get_opts

sub get_params {
    my $args = shift;
    return { map { split('=', $_, 2) } @$args };
} # get_params

sub merge_hash {
    my $to   = shift;
    my $from = shift;
    my $keys = shift || [keys(%$to)];

    foreach my $key (@$keys) {
        if (exists($from->{$key})) {
            if (ref($from->{$key}) eq 'HASH') {
                $to->{$key} ||= {};
                merge_hash($to->{$key}, $from->{$key}, [keys(%{$from->{$key}})]);
            }
            else {
                $to->{$key} = $from->{$key};
            }
        }
    } # foreach

    return $to;
} # merge_hash

sub get_json {
    my $text = shift;
    my $json = undef;
    
    if (-r $text) {
        open(my $fh, '<', $text) or die "$OS_ERROR";
        local $INPUT_RECORD_SEPARATOR = undef;
        $text = <$fh>;
        close($fh);
    }

    eval {
        $json = from_json($text);
    };

    if ($EVAL_ERROR) {
        return {};
    }

    return $json;
} # get_json

sub get_hosts {
    my $params = shift;
    my $hosts  = {};

    $hosts->{ac_host} = get_param($params->{ac_host}, $conf->{ac_host});
    $hosts->{io_host} = get_param($params->{io_host}, $conf->{io_host});
    $hosts->{up_host} = get_param($params->{up_host}, $conf->{up_host});
    $hosts->{rs_host} = get_param($params->{rs_host}, $conf->{rs_host});
    $hosts->{eu_host} = get_param($params->{eu_host}, $conf->{eu_host});
    $hosts->{uc_host} = get_param($params->{uc_host}, $conf->{uc_host});

    return $hosts;
} # get_hosts

sub read_conf {
    my $fls = shift;

    my $conf = {};
    foreach my $fl (@$fls) {
        next if (not defined($fl) or $fl eq q{});

        open(my $fh, '<', $fl) or die "$!";
        local $/ = undef;
        my $text = <$fh>;
        close($fh);

        my $new_conf = undef;
        eval {
            $new_conf = from_json($text);
        };
        next if ($@);

        merge_hash($conf, $new_conf, [keys(%$new_conf)]);
    } # foreach

    return $conf;
} # read_conf

sub gen_client {
    my $params = shift;
    my $hosts  = shift;

    my $client_id     = get_param($params->{client_id});
    my $client_secret = get_param($params->{client_secret});
    my $username      = get_param($params->{username});
    my $password      = get_param($params->{password});

    if (defined($username) and defined($password)) {
        my $token = QBox::Auth::Token->new($hosts, $client_id, $client_secret);
        my $auth = QBox::Auth::Password->new($token, $username, $password);
        return QBox::Client->new($auth);
    }

    my $acs_key = get_param($params->{acs_key}, 'Put your ACCESS KEY here');
    my $scr_key = get_param($params->{scr_key}, 'Put your SECRET KEY here');

    my $policy = get_param($params->{policy});
    if (defined($policy) and $policy ne q{}) {
        if (ref($policy) eq q{}) {
            $policy = from_json($policy);
        }
        $policy = QBox::Auth::Policy->new($policy);
        my $auth = QBox::Auth::UpToken->new($acs_key, $scr_key, $policy);
        return QBox::Client->new($auth);
    }

    my $auth = QBox::Auth::Digest->new($acs_key, $scr_key);
    return QBox::Client->new($auth);
} # gen_client

### rs
my $rs_get_rs_params = sub {
    my $params = shift;

    my $rs_params = {};

    $rs_params->{src_file}        = get_param($params->{src}, q{});
    $rs_params->{bucket}          = get_param($params->{bkt}, 'Bucket');
    $rs_params->{key}             = get_param($params->{key}, basename($rs_params->{src_file}));
    $rs_params->{mime}            = get_param($params->{mime}, 'application/octet-stream');
    $rs_params->{meta}            = get_param($params->{meta});
    $rs_params->{other_params}    = get_param($params->{params});
    $rs_params->{callback_params} = get_param($params->{callback_params});

    $rs_params->{attr}            = get_param($params->{attr});
    $rs_params->{base}            = get_param($params->{base});
    $rs_params->{domain}          = get_param($params->{domain});

    return $rs_params;
};

my $read_progress_as_plain_text = sub {
    my $fh = shift;

    my $prog = {};
    my $line = undef;

    $line = <$fh>;
    if ($line !~ m/^block_count=(\d+)\n/) {
        die "Invalid progress file: No block count.";
    }
    $prog->{blk_count} = $1;

    $prog->{checksums} = [];
    for (my $i = 0; $i < $prog->{blk_count}; ++$i) {
        $line = <$fh>;
        if ($line !~ m/^checksum=(.*)\n/) {
            die "Invalid progress file: Invalid checksum.";
        }

        push @{$prog->{checksums}}, { value => $1 };
    } # for

    $prog->{progs} = [];
    for (my $i = 0; $i < $prog->{blk_count}; ++$i) {
        my $pg = {};

        $line = <$fh>;
        if ($line !~ m/^offset=(\d+)\n/) {
            die "Invalid progress file: Invalid offset.";
        }
        $pg->{offset} = $1;

        $line = <$fh>;
        if ($line !~ m/^rest_size=(\d+)\n/) {
            die "Invalid progress file: Invalid rest size.";
        }
        $pg->{rest_size} = $1;

        $line = <$fh>;
        if ($line !~ m/^ctx=(.*)\n/) {
            die "Invalid progress file: Invalid context.";
        }
        $pg->{ctx} = $1;

        push @{$prog->{progs}}, $pg;
    } # for

    return $prog;
};

my $read_progress = sub {
    my $params = shift;
    
    my $prog_fl = $params->{prog_fl};
    return undef if (not defined($prog_fl) or $prog_fl eq q{});
    return undef if (not -r $prog_fl);

    open(my $fh, '<', $prog_fl) or die "$OS_ERROR";

    my $prog = undef;
    if ($prog_fl =~ m/json$/i) {
        local $/ = undef;
        my $text = <$fh>;
        $prog = from_json($text);
    }
    else {
        $prog = $read_progress_as_plain_text->($fh);
    }

    close($fh);
    return $prog;
};

my $write_progress_as_plain_text = sub {
    my $fh   = shift;
    my $prog = shift;

    printf {$fh} "block_count=%d\n", $prog->{blk_count};

    foreach my $cksum (@{$prog->{checksums}}) {
        printf {$fh} "checksum=%s\n", ($cksum->{value} || q{});
    } # foreach

    foreach my $pg (@{$prog->{progs}}) {
        printf {$fh} "offset=%d\n", $pg->{offset};
        printf {$fh} "rest_size=%d\n", $pg->{rest_size};
        printf {$fh} "ctx=%s\n", ($pg->{ctx} || q{});
    } # foreach
};

my $write_progress = sub {
    my $params = shift;
    my $prog   = shift;

    my $prog_fl = $params->{prog_fl};
    return if (not defined($prog_fl) or $prog_fl eq q{});

    open(my $fh, '>', $prog_fl) or die "$OS_ERROR";

    if ($prog_fl =~ m/json$/i) {
        printf {$fh} "%s", to_json($prog, { pretty => 1 });
    }
    else {
        $write_progress_as_plain_text->($fh, $prog);
    }

    close($fh);
};

my $blk_abort = sub {
    my $params    = shift;
    my $blk_index = shift;
    my $checksum  = shift;

    my $stop_idx = $params->{stop_idx};
    if (defined($stop_idx) and $blk_index == $stop_idx) {
        print "Abort uploading block(#${stop_idx}).\n";
        return 0;
    }
    return 1;
};

my $blk_notify = sub {
    my $params    = shift;
    my $blk_index = shift;
    my $checksum  = shift;

    printf "blk_index=%d, checksum=[%s]\n", $blk_index, $checksum->{value};
    $blk_abort->($params, $blk_index, $checksum);
};

my $chk_abort = sub {
    my $params    = shift;
    my $blk_index = shift;
    my $prog      = shift;

    my $stop_idx = $params->{stop_idx};
    if (defined($stop_idx) and $blk_index == $stop_idx) {
        my $stop_size = $params->{stop_size};
        if (defined($stop_size) and $prog->{offset} >= $stop_size) {
            print "Abort uploading chunk(#$prog->{stop_idx}, \@$prog->{offset}).\n";
            return 0;
        }
    }
    return 1;
};

my $chk_notify = sub {
    my $params    = shift;
    my $blk_index = shift;
    my $prog      = shift;

    printf "blk_index=%d, uploaded=%d, rest=%d, ctx=[%s]\n",
        $blk_index, $prog->{offset}, $prog->{rest_size}, $prog->{ctx};
    $chk_abort->($params, $blk_index, $prog);
};

### eu
my $eu_gen_settings = sub {
    my $params   = shift;
    my $settings = shift || {};

    my $wms   = get_param($params->{wms});
    my $names = QBox::EU::wm_setting_names();

    merge_hash($settings, $conf, $names);
    if (defined($wms) and $wms ne q{}) {
        merge_hash($settings, get_json($wms), $names);
    }
    merge_hash($settings, $params, $names);

    return $settings;
};

my %cmd_alias = (
    'get'   => 'rs.get',
    'stat'  => 'rs.stat',
    'pub'   => 'rs.publish',
    'unpub' => 'rs.unpublish',
    'puta'  => 'rs.put-auth',
    'putf'  => 'rs.put-file',
    'rput'  => 'rs.resumable-put',
    'del'   => 'rs.delete',
    'drop'  => 'rs.drop',
    'query' => 'up.query',
    'wmget' => 'eu.wmget',
    'wmset' => 'eu.wmset',
    'wmmod' => 'eu.wmmod',
    'appi'  => 'uc.app-info',
    'nacs'  => 'uc.new-access',
    'dacs'  => 'uc.delete-access',
);

my %cmds = (
    'rs.get' => sub { # command
        my ($client, $params, $hosts) = @_;

        my $rs_params = $rs_get_rs_params->($params);
        my $rs = QBox::RS->new($client, $hosts);
        return $rs->get(
            $rs_params->{bucket},
            $rs_params->{key},
            $rs_params->{attr},
            $rs_params->{base},
        );
    },
    'rs.stat' => sub { # command
        my ($client, $params, $hosts) = @_;

        my $rs_params = $rs_get_rs_params->($params);
        my $rs = QBox::RS->new($client, $hosts);
        return $rs->stat($rs_params->{bucket}, $rs_params->{key});
    },
    'rs.publish' => sub { # command
        my ($client, $params, $hosts) = @_;

        my $rs_params = $rs_get_rs_params->($params);
        my $rs = QBox::RS->new($client, $hosts);
        return $rs->publish($rs_params->{bucket}, $rs_params->{domain});
    },
    'rs.unpublish' => sub { # command
        my ($client, $params, $hosts) = @_;

        my $rs_params = $rs_get_rs_params->($params);
        my $rs = QBox::RS->new($client, $hosts);
        return $rs->unpublish($rs_params->{domain});
    },
    'rs.put-auth' => sub { # command
        my ($client, $params, $hosts) = @_;

        my $expires_in   = get_param($params->{expires_in}, 30);
        my $callback_url = get_param($params->{callback_url});

        my $rs = QBox::RS->new($client, $hosts);
        return $rs->put_auth($expires_in, $callback_url);
    },
    'rs.put-file' => sub { # command
        my ($client, $params, $hosts) = @_;

        my $rs_params = $rs_get_rs_params->($params);

        my $rs = QBox::RS->new($client, $hosts);
        return $rs->put_file(
            $rs_params->{bucket},
            $rs_params->{key},
            $rs_params->{mime_type},
            $rs_params->{src_file},
            $rs_params->{meta},
        );
    },
    'rs.resumable-put' => sub { # command
        my ($client, $params, $hosts) = @_;

        my $rs_params = $rs_get_rs_params->($params);

        my $fsize     = (stat($rs_params->{src_file}))[7];
        my $reader_at = QBox::ReaderAt::File->new($rs_params->{src_file});

        my $notify_blk = get_param($params->{notify_blk});
        my $notify_chk = get_param($params->{notify_chk});

        my $notify_params = {};
        $notify_params->{stop_idx}  = get_param($params->{stop_idx});
        $notify_params->{stop_size} = get_param($params->{stop_size});
        $notify_params->{prog_fl}   = get_param($params->{prog_fl});

        if (defined($notify_params->{stop_size})) {
            $notify_params->{stop_idx} ||= 0;
        }

        my $ret  = undef;
        my $err  = undef;
        my $prog = $read_progress->($notify_params);

        my $rs = QBox::RS->new($client, $hosts);
        ($ret, $err, $prog) = $rs->resumale_put(
            $prog,
            defined($notify_blk) ? $blk_notify : $blk_abort,
            defined($notify_chk) ? $chk_notify : $chk_abort,
            $notify_params,
            qbox_make_entry($rs_params->{bucket}, $rs_params->{key}),
            $rs_params->{mime},
            $reader_at,
            $fsize,
            $rs_params->{meta},
            $rs_params->{other_params},
            $rs_params->{callback_params},
        );

        if ($err->{code} != 200) {
            $write_progress->($notify_params, $prog);
        }
        elsif ($notify_params->{prog_fl} and -w $notify_params->{prog_fl}) {
            unlink($notify_params->{prog_fl});
        }

        return $ret, $err;
    },
    'rs.delete' => sub { # command
        my ($client, $params, $hosts) = @_;

        my $rs_params = $rs_get_rs_params->($params);
        my $rs = QBox::RS->new($client, $hosts);
        return $rs->delete($rs_params->{bucket}, $rs_params->{key});
    },
    'rs.drop' => sub { # command
        my ($client, $params, $hosts) = @_;

        my $rs_params = $rs_get_rs_params->($params);
        my $rs = QBox::RS->new($client, $hosts);
        return $rs->drop($rs_params->{bucket});
    },
    'up.query' => sub { # command
        my ($client, $params, $hosts) = @_;

        my $prog_fl = get_param($params->{prog_fl});
        my $prog    = $read_progress->({ prog_fl => $prog_fl });

        if (not defined($prog)) {
            return undef, { code => 299, message => 'No correct progress infomation.' };
        }

        my $up = QBox::UP->new($client, $hosts);
        return $up->query($prog->{checksums});
    },
    'eu.wmget' => sub { # command
        my ($client, $params, $hosts) = @_;

        my $customer = get_param($params->{customer});
        my $eu = QBox::EU->new($client, $hosts);
        return $eu->wmget($customer);
    },
    'eu.wmset' => sub { # command
        my ($client, $params, $hosts) = @_;

        my $settings = $eu_gen_settings->($params);
        my $eu = QBox::EU->new($client, $hosts);
        return $eu->wmset($settings);
    },
    'uc.app-info' => sub { # command
        my ($client, $params, $hosts) = @_;

        my $app = get_param($params->{app});

        my $uc = QBox::UC->new($client, $hosts);
        return $uc->app_info($app);
    },
    'uc.new-access' => sub { # command
        my ($client, $params, $hosts) = @_;

        my $app = get_param($params->{app});

        my $uc = QBox::UC->new($client, $hosts);
        return $uc->new_access($app);
    },
    'uc.delete-access' => sub { # command
        my ($client, $params, $hosts) = @_;

        my $app     = get_param($params->{app});
        my $acs_key = get_param($params->{acs_key});

        my $uc = QBox::UC->new($client, $hosts);
        return $uc->delete_access($app, $acs_key);
    },
);

my %ext_cmds = (
    'eu.wmmod' => sub { # command extended
        my ($client, $params, $hosts) = @_;

        my ($settings, $err) = $cmds{'eu.wmget'}->($client, $params, $hosts);
        if ($err->{code} != 200) {
            return undef, $err;
        }

        $settings = $eu_gen_settings->($params, $settings);
        my $eu = QBox::EU->new($client, $hosts);
        return $eu->wmset($settings);
    },
);

my ($args, $opts) = get_opts(\@ARGV);
$conf = read_conf($opts->{conf});

my $cmd = shift(@$args);

if (not defined($cmd) or $cmd eq q{}) {
    my $prog_nm = basename($0);
    print "Usage: ${prog_nm} CMD [PARAM=ARG [PARAM=ARG [...]]]\n";
    exit(1);
}

$cmd = $cmd_alias{$cmd} || $cmd;
my $cmd_sub = $ext_cmds{$cmd} || $cmds{$cmd};
if (not defined($cmd_sub)) {
    print STDERR "Unknown command '$cmd'.\n";
    exit(1);
}

if ($debug) {
    QBox::Debug::set_callback(sub {
        my $data    = shift;
        my $title   = shift;
        my $context = shift;

        my $type = ref($context);
        if ($type eq 'HASH') {
            printf STDERR "${title}=%s\n", fmt_json($context);
        }
        else {
            print STDERR "${title}=[${context}]\n";
        }
    });
}

my $ori_params = get_params($args);
my $params = {};
if (exists($conf->{params}) and ref($conf->{params}) eq 'HASH') {
    merge_hash($params, $conf->{params}, [keys(%{$conf->{params}})]);
}
merge_hash($params, $ori_params, [keys(%$ori_params)]);

my $hosts  = get_hosts($params);
my $client = gen_client($params, $hosts);

my ($ret, $err) = $cmd_sub->($client, $params, $hosts);

if ($verbose or ($err->{code} != 200)) {
    printf STDERR "%d %s\n", $err->{code}, $err->{message};
}

$ret ||= {};
printf "%s\n", fmt_json($ret);

exit 0;
